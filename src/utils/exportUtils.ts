import { GeneratedTest, TestFramework } from '../types';

export interface ExportOptions {
  format: 'file' | 'clipboard' | 'project';
  includeComments?: boolean;
  includeImports?: boolean;
  fileName?: string;
  projectStructure?: 'flat' | 'organized';
}

export class TestExporter {
  static async exportToClipboard(test: GeneratedTest, options: ExportOptions = { format: 'clipboard' }): Promise<void> {
    const exportedCode = this.formatTestCode(test, options);
    
    try {
      await navigator.clipboard.writeText(exportedCode);
    } catch (error) {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = exportedCode;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
    }
  }

  static async exportToFile(test: GeneratedTest, options: ExportOptions): Promise<void> {
    const exportedCode = this.formatTestCode(test, options);
    const fileName = options.fileName || this.generateFileName(test);
    
    const blob = new Blob([exportedCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }

  static async exportMultipleTests(tests: GeneratedTest[], options: ExportOptions): Promise<void> {
    if (options.format === 'file') {
      if (options.projectStructure === 'organized') {
        await this.exportAsProjectStructure(tests, options);
      } else {
        await this.exportAsZip(tests, options);
      }
    } else if (options.format === 'clipboard') {
      const combinedCode = tests.map(test => this.formatTestCode(test, options)).join('\n\n');
      await navigator.clipboard.writeText(combinedCode);
    }
  }

  private static formatTestCode(test: GeneratedTest, options: ExportOptions): string {
    let code = test.code;
    
    if (options.includeComments !== false) {
      code = this.addMetadataComments(test, code);
    }
    
    if (options.includeImports !== false) {
      code = this.addImports(test.framework, code);
    }
    
    return code;
  }

  private static addMetadataComments(test: GeneratedTest, code: string): string {
    const timestamp = new Date(test.timestamp).toISOString();
    const commentStyle = this.getCommentStyle(test.framework.language);
    
    const metadata = [
      `${commentStyle.start} Generated by AI TestGen`,
      `${commentStyle.line} Framework: ${test.framework.name} (${test.framework.language})`,
      `${commentStyle.line} Generated: ${timestamp}`,
      `${commentStyle.line} Actions: ${test.actions.length} recorded interactions`,
      commentStyle.end ? commentStyle.end : '',
      ''
    ].filter(line => line !== '').join('\n');
    
    return metadata + code;
  }

  private static addImports(framework: TestFramework, code: string): string {
    // Check if imports already exist
    if (this.hasImports(code, framework)) {
      return code;
    }
    
    const imports = this.getFrameworkImports(framework);
    return imports + '\n\n' + code;
  }

  private static hasImports(code: string, framework: TestFramework): boolean {
    const lines = code.split('\n');
    const firstNonEmptyLine = lines.find(line => line.trim() !== '');
    
    if (!firstNonEmptyLine) return false;
    
    // Check for common import patterns
    const importPatterns = [
      /^import\s+/,           // JavaScript/TypeScript imports
      /^from\s+.*\s+import/,  // Python imports
      /^import\s+.*\./,       // Java imports
      /^using\s+/,            // C# using statements
    ];
    
    return importPatterns.some(pattern => pattern.test(firstNonEmptyLine.trim()));
  }

  private static getFrameworkImports(framework: TestFramework): string {
    const imports: Record<string, Record<string, string>> = {
      'playwright-js': {
        'JavaScript': "import { test, expect } from '@playwright/test';",
        'TypeScript': "import { test, expect } from '@playwright/test';"
      },
      'playwright-python': {
        'Python': "from playwright.sync_api import Page, expect\nimport pytest"
      },
      'cypress-js': {
        'JavaScript': "/// <reference types=\"cypress\" />",
        'TypeScript': "/// <reference types=\"cypress\" />"
      },
      'selenium-java': {
        'Java': "import org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.support.ui.WebDriverWait;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;"
      },
      'selenium-python': {
        'Python': "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport pytest"
      }
    };
    
    return imports[framework.id]?.[framework.language] || '';
  }

  private static getCommentStyle(language: string): { start: string; line: string; end?: string } {
    const styles: Record<string, { start: string; line: string; end?: string }> = {
      'JavaScript': { start: '/**', line: ' *', end: ' */' },
      'TypeScript': { start: '/**', line: ' *', end: ' */' },
      'Python': { start: '"""', line: '', end: '"""' },
      'Java': { start: '/**', line: ' *', end: ' */' },
      'C#': { start: '/**', line: ' *', end: ' */' }
    };
    
    return styles[language] || { start: '//', line: '//' };
  }

  private static generateFileName(test: GeneratedTest): string {
    const timestamp = new Date(test.timestamp).toISOString().slice(0, 19).replace(/[:.]/g, '-');
    const frameworkName = test.framework.name.toLowerCase().replace(/\s+/g, '-');
    
    const extensions: Record<string, string> = {
      'JavaScript': '.js',
      'TypeScript': '.ts',
      'Python': '.py',
      'Java': '.java',
      'C#': '.cs'
    };
    
    const extension = extensions[test.framework.language] || '.txt';
    return `${frameworkName}-test-${timestamp}${extension}`;
  }

  private static async exportAsZip(tests: GeneratedTest[], options: ExportOptions): Promise<void> {
    // For now, we'll export as individual files
    // In a real implementation, you might want to use a library like JSZip
    for (const test of tests) {
      await this.exportToFile(test, { ...options, format: 'file' });
    }
  }

  private static async exportAsProjectStructure(tests: GeneratedTest[], options: ExportOptions): Promise<void> {
    // Group tests by framework
    const testsByFramework = tests.reduce((acc, test) => {
      const key = test.framework.id;
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(test);
      return acc;
    }, {} as Record<string, GeneratedTest[]>);

    // Export each framework group
    for (const [frameworkId, frameworkTests] of Object.entries(testsByFramework)) {
      const framework = frameworkTests[0].framework;
      const projectStructure = this.generateProjectStructure(framework, frameworkTests);
      
      // For now, export as a single file with project structure comments
      const combinedCode = this.formatProjectStructure(projectStructure, frameworkTests, options);
      const fileName = `${framework.name.toLowerCase().replace(/\s+/g, '-')}-project-structure.txt`;
      
      const blob = new Blob([combinedCode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
    }
  }

  private static generateProjectStructure(framework: TestFramework, tests: GeneratedTest[]): any {
    const structures: Record<string, any> = {
      'playwright-js': {
        'tests/': {
          'example.spec.js': 'test files',
        },
        'playwright.config.js': 'configuration',
        'package.json': 'dependencies'
      },
      'cypress-js': {
        'cypress/': {
          'e2e/': 'test files',
          'fixtures/': 'test data',
          'support/': 'commands and utilities'
        },
        'cypress.config.js': 'configuration'
      },
      'selenium-java': {
        'src/': {
          'test/': {
            'java/': 'test classes'
          }
        },
        'pom.xml': 'Maven configuration'
      },
      'selenium-python': {
        'tests/': 'test files',
        'conftest.py': 'pytest configuration',
        'requirements.txt': 'dependencies'
      }
    };
    
    return structures[framework.id] || { 'tests/': 'test files' };
  }

  private static formatProjectStructure(structure: any, tests: GeneratedTest[], options: ExportOptions): string {
    const framework = tests[0].framework;
    let output = `# ${framework.name} Test Project Structure\n\n`;
    
    output += `## Recommended Project Structure:\n\n`;
    output += this.formatStructureTree(structure, 0);
    
    output += `\n\n## Generated Test Files:\n\n`;
    
    tests.forEach((test, index) => {
      output += `### Test ${index + 1} - ${new Date(test.timestamp).toLocaleString()}\n\n`;
      output += '```' + framework.language.toLowerCase() + '\n';
      output += this.formatTestCode(test, options);
      output += '\n```\n\n';
    });
    
    return output;
  }

  private static formatStructureTree(obj: any, depth: number): string {
    let result = '';
    const indent = '  '.repeat(depth);
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object') {
        result += `${indent}${key}\n`;
        result += this.formatStructureTree(value, depth + 1);
      } else {
        result += `${indent}${key} (${value})\n`;
      }
    }
    
    return result;
  }
}

// Utility functions for project integration
export class ProjectIntegration {
  static generatePackageJson(framework: TestFramework): string {
    const packages: Record<string, any> = {
      'playwright-js': {
        name: 'ai-generated-tests',
        version: '1.0.0',
        scripts: {
          test: 'playwright test',
          'test:headed': 'playwright test --headed',
          'test:debug': 'playwright test --debug'
        },
        devDependencies: {
          '@playwright/test': '^1.40.0'
        }
      },
      'cypress-js': {
        name: 'ai-generated-tests',
        version: '1.0.0',
        scripts: {
          'cy:open': 'cypress open',
          'cy:run': 'cypress run'
        },
        devDependencies: {
          cypress: '^13.0.0'
        }
      }
    };
    
    return JSON.stringify(packages[framework.id] || {}, null, 2);
  }

  static generateConfigFile(framework: TestFramework): string {
    const configs: Record<string, string> = {
      'playwright-js': `import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
});`,
      'cypress-js': `import { defineConfig } from 'cypress'

export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
    baseUrl: 'http://localhost:3000',
    viewportWidth: 1280,
    viewportHeight: 720,
  },
})`
    };
    
    return configs[framework.id] || '';
  }
}